// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var EventEmitter, FSWatcher, createFSEventsInstance, directoryEndRe, fs, fsevents, isBinary, isDarwin, nodeVersion, os, recursiveReaddir, sysPath,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  os = require('os');

  sysPath = require('path');

  isBinary = require('./is-binary');

  try {
    fsevents = require('fsevents');
    recursiveReaddir = require('recursive-readdir');
  } catch (_error) {
    fsevents = null;
    recursiveReaddir = null;
  }

  nodeVersion = process.versions.node.substring(0, 3);

  createFSEventsInstance = function(path, callback) {
    var watcher;
    watcher = new fsevents.FSEvents(path);
    watcher.on('fsevent', callback);
    return watcher;
  };

  directoryEndRe = /[\\\/]$/;

  isDarwin = os.platform() === 'darwin';

  exports.FSWatcher = FSWatcher = (function(_super) {
    __extends(FSWatcher, _super);

    function FSWatcher(options) {
      if (options == null) {
        options = {};
      }
      this.close = __bind(this.close, this);
      FSWatcher.__super__.constructor.apply(this, arguments);
      this.watched = Object.create(null);
      this.watchers = [];
      if (options.persistent == null) {
        options.persistent = false;
      }
      if (options.ignoreInitial == null) {
        options.ignoreInitial = false;
      }
      if (options.ignorePermissionErrors == null) {
        options.ignorePermissionErrors = false;
      }
      if (options.interval == null) {
        options.interval = 100;
      }
      if (options.binaryInterval == null) {
        options.binaryInterval = 300;
      }
      if (options.usePolling == null) {
        options.usePolling = false;
      }
      if (options.useFsEvents == null) {
        options.useFsEvents = !options.usePolling && isDarwin;
      }
      this.enableBinaryInterval = options.binaryInterval !== options.interval;
      this._isIgnored = (function(ignored) {
        switch (toString.call(ignored)) {
          case '[object RegExp]':
            return function(string) {
              return ignored.test(string);
            };
          case '[object Function]':
            return ignored;
          default:
            return function() {
              return false;
            };
        }
      })(options.ignored);
      this.options = options;
      Object.freeze(options);
    }

    FSWatcher.prototype._getWatchedDir = function(directory) {
      var dir, _base;
      dir = directory.replace(directoryEndRe, '');
      return (_base = this.watched)[dir] != null ? (_base = this.watched)[dir] : _base[dir] = [];
    };

    FSWatcher.prototype._addToWatchedDir = function(directory, basename) {
      var watchedFiles;
      watchedFiles = this._getWatchedDir(directory);
      return watchedFiles.push(basename);
    };

    FSWatcher.prototype._removeFromWatchedDir = function(directory, file) {
      var watchedFiles;
      watchedFiles = this._getWatchedDir(directory);
      return watchedFiles.some(function(watchedFile, index) {
        if (watchedFile === file) {
          watchedFiles.splice(index, 1);
          return true;
        }
      });
    };

    FSWatcher.prototype._hasReadPermissions = function(stats) {
      return Boolean(4 & parseInt((stats.mode & 0x1ff).toString(8)[0]));
    };

    FSWatcher.prototype._remove = function(directory, item) {
      var fullPath, isDirectory, nestedDirectoryChildren,
        _this = this;
      fullPath = sysPath.join(directory, item);
      isDirectory = this.watched[fullPath];
      nestedDirectoryChildren = this._getWatchedDir(fullPath).slice();
      this._removeFromWatchedDir(directory, item);
      nestedDirectoryChildren.forEach(function(nestedItem) {
        return _this._remove(fullPath, nestedItem);
      });
      if (this.options.usePolling) {
        fs.unwatchFile(fullPath);
      }
      delete this.watched[fullPath];
      if (isDirectory) {
        return this.emit('unlinkDir', fullPath);
      } else {
        return this.emit('unlink', fullPath);
      }
    };

    FSWatcher.prototype._watchWithFsEvents = function(path) {
      var watcher,
        _this = this;
      watcher = createFSEventsInstance(path, function(path, flags) {
        var emit, info;
        if (_this._isIgnored(path)) {
          return;
        }
        info = fsevents.getInfo(path, flags);
        emit = function(event) {
          var name;
          name = info.type === 'file' ? event : "" + event + "Dir";
          if (event === 'add' || event === 'addDir') {
            _this._addToWatchedDir(sysPath.dirname(path), sysPath.basename(path));
          } else if (event === 'unlink' || event === 'unlinkDir') {
            _this._remove(sysPath.dirname(path), sysPath.basename(path));
            return;
          }
          return _this.emit(name, path);
        };
        switch (info.event) {
          case 'created':
            return emit('add');
          case 'modified':
            return emit('change');
          case 'deleted':
            return emit('unlink');
          case 'moved':
            return fs.stat(path, function(error, stats) {
              return emit((error || !stats ? 'unlink' : 'add'));
            });
        }
      });
      return this.watchers.push(watcher);
    };

    FSWatcher.prototype._watch = function(item, callback) {
      var basename, directory, options, parent, watcher;
      if (callback == null) {
        callback = (function() {});
      }
      directory = sysPath.dirname(item);
      basename = sysPath.basename(item);
      parent = this._getWatchedDir(directory);
      if (parent.indexOf(basename) !== -1) {
        return;
      }
      this._addToWatchedDir(directory, basename);
      options = {
        persistent: this.options.persistent
      };
      if (this.options.usePolling) {
        options.interval = this.enableBinaryInterval && isBinary(basename) ? this.options.binaryInterval : this.options.interval;
        return fs.watchFile(item, options, function(curr, prev) {
          if (curr.mtime.getTime() > prev.mtime.getTime()) {
            return callback(item, curr);
          }
        });
      } else {
        watcher = fs.watch(item, options, function(event, path) {
          return callback(item);
        });
        return this.watchers.push(watcher);
      }
    };

    FSWatcher.prototype._handleFile = function(file, stats, initialAdd) {
      var _this = this;
      if (initialAdd == null) {
        initialAdd = false;
      }
      this._watch(file, function(file, newStats) {
        return _this.emit('change', file, newStats);
      });
      if (!(initialAdd && this.options.ignoreInitial)) {
        return this.emit('add', file, stats);
      }
    };

    FSWatcher.prototype._handleDir = function(directory, stats, initialAdd) {
      var read,
        _this = this;
      read = function(directory, initialAdd) {
        return fs.readdir(directory, function(error, current) {
          var previous;
          if (error != null) {
            return _this.emit('error', error);
          }
          if (!current) {
            return;
          }
          previous = _this._getWatchedDir(directory);
          previous.filter(function(file) {
            return current.indexOf(file) === -1;
          }).forEach(function(file) {
            return _this._remove(directory, file);
          });
          return current.filter(function(file) {
            return previous.indexOf(file) === -1;
          }).forEach(function(file) {
            return _this._handle(sysPath.join(directory, file), initialAdd);
          });
        });
      };
      read(directory, initialAdd);
      this._watch(directory, function(dir) {
        return read(dir, false);
      });
      if (!(initialAdd && this.options.ignoreInitial)) {
        return this.emit('addDir', directory, stats);
      }
    };

    FSWatcher.prototype._handle = function(item, initialAdd) {
      var _this = this;
      if (this._isIgnored(item)) {
        return;
      }
      return fs.realpath(item, function(error, path) {
        if (error && error.code === 'ENOENT') {
          return;
        }
        if (error != null) {
          return _this.emit('error', error);
        }
        return fs.stat(path, function(error, stats) {
          if (error != null) {
            return _this.emit('error', error);
          }
          if (_this.options.ignorePermissionErrors && (!_this._hasReadPermissions(stats))) {
            return;
          }
          if (_this._isIgnored.length === 2 && _this._isIgnored(item, stats)) {
            return;
          }
          if (stats.isFile()) {
            _this._handleFile(item, stats, initialAdd);
          }
          if (stats.isDirectory()) {
            return _this._handleDir(item, stats, initialAdd);
          }
        });
      });
    };

    FSWatcher.prototype.emit = function() {
      var args, event;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      FSWatcher.__super__.emit.apply(this, [event].concat(__slice.call(args)));
      if (event === 'add' || event === 'addDir' || event === 'change' || event === 'unlink' || event === 'unlinkDir') {
        return FSWatcher.__super__.emit.apply(this, ['all', event].concat(__slice.call(args)));
      }
    };

    FSWatcher.prototype._addToFsEvents = function(files) {
      var handle,
        _this = this;
      handle = function(path) {
        return _this.emit('add', path);
      };
      files.forEach(function(file) {
        if (!_this.options.ignoreInitial) {
          fs.stat(file, function(error, stats) {
            if (error != null) {
              return _this.emit('error', error);
            }
            if (stats.isDirectory()) {
              return recursiveReaddir(file, function(error, dirFiles) {
                if (error != null) {
                  return _this.emit('error', error);
                }
                return dirFiles.filter(function(path) {
                  return !_this._isIgnored(path);
                }).forEach(handle);
              });
            } else {
              return handle(file);
            }
          });
        }
        return _this._watchWithFsEvents(file);
      });
      return this;
    };

    FSWatcher.prototype.add = function(files) {
      var _this = this;
      if (this._initialAdd == null) {
        this._initialAdd = true;
      }
      if (!Array.isArray(files)) {
        files = [files];
      }
      if (this.options.useFsEvents) {
        return this._addToFsEvents(files);
      }
      files.forEach(function(file) {
        return _this._handle(file, _this._initialAdd);
      });
      this._initialAdd = false;
      return this;
    };

    FSWatcher.prototype.close = function() {
      var _this = this;
      this.watchers.forEach(function(watcher) {
        if (_this.options.useFsEvents) {
          return watcher.stop();
        } else {
          return watcher.close();
        }
      });
      if (this.options.usePolling) {
        Object.keys(this.watched).forEach(function(directory) {
          return _this.watched[directory].forEach(function(file) {
            return fs.unwatchFile(sysPath.join(directory, file));
          });
        });
      }
      this.watched = Object.create(null);
      this.removeAllListeners();
      return this;
    };

    return FSWatcher;

  })(EventEmitter);

  exports.watch = function(files, options) {
    return new FSWatcher(options).add(files);
  };

}).call(this);
